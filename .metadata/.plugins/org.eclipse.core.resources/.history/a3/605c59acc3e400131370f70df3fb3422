/*
 * CVirtualConnection.h
 *
 *  Created on: Dec 31, 2013
 *      Author: root
 */

#ifndef CVIRTUALCONNECTION_H_
#define CVIRTUALCONNECTION_H_
//Base class
#include "CConnection.h"
//Packet collectors
#include "CPacketCollector.h"
//
#include <boost/signals2/mutex.hpp>
#define NUMBER_OF_CONNECTED_DEVICES 2
#include <algorithm>

/**
 * A connection class of a virtual connection
 */
class CVirtualConnection: public CConnection
{
public:

	/**
	 * Constructor - determining the MAC address of the connection to be set
	 */
	CVirtualConnection();

	/**
	 * Retrieving of packets from a virtual connection
	 * @param routerNumber Virtual connections has 2 virtual routers attached to them, in which the correct packet collector should be chosen
	 * @return first packet in the packet collector's FIFO
	 */
	virtual Crafter::Packet* GetPacket(int routerNumber=NO_CHOICE_OF_PACKET_COLLECTOR);

	/**
	 * Sending of packets from a virtual connection
	 * @param packet The packet to be sent
	 * @param routerNumber Virtual connections has 2 virtual routers attached to them, in which the correct packet collector should be chosen
	 */
	virtual void SendPacket(Packet* packet,int routerNumber=NO_CHOICE_OF_PACKET_COLLECTOR);

	/**
	 * Getter of the connection's IPv4 address
	 * @return
	 */
	CUIPV4*& getGetwayAddress() {return mUniqueIPForConnection;}

	/**
	 * Getter of the connection's MAC address
	 * @return
	 */
	virtual string GetMAC()const{return mMacAddress;};

	/**
	 * Each virtual connection holds 2 routers, when sending and receiving packets they should move from
	 * one router to the other, therefore the router numbers are being saved
	 * @param routerNumber involved router in this virtual connection
	 */
	void AddInvolvedRouter(const unsigned int & routerNumber);

	/**
	 * Verifying if a certain router is using the current connection
	 * @param routerNumber
	 * @return
	 */
	bool IsInvolved(const unsigned int &routerNumber){return std::find(mInvolvedRoutersByNumber.begin()
			, mInvolvedRoutersByNumber.end(), routerNumber)!=mInvolvedRoutersByNumber.end();}
	virtual ~CVirtualConnection();
	void AddRoutingTableReference(map<string,pair<CConnection const*,string> > * routTable, int routerNumber);
	virtual vector<pair<string, string> >& GetTable() ;

	/**
	 * Checking if the current connection is physical or virtual, saving time on dynamic casting
	 * since it is needed in order to determine the report finishing of each packet
	 * @return true if the connection is physical
	 */
	bool isPhysical(){return false;}
private:
	vector<unsigned int> mInvolvedRoutersByNumber;
	CPacketCollector mPacketCollectors[NUMBER_OF_CONNECTED_DEVICES];
	map<unsigned int ,unsigned int > mRouterToPacketCollectorMap;
	//MAP < IP , <Connection,MAC> > reference
	map<string,pair<CConnection const*,string> > * mRoutingTable[NUMBER_OF_CONNECTED_DEVICES];
	set< string > mCombinedRoutingTable;
	vector<pair<string, string> > mRoutingToReturn;
	string mMacAddress;
	CUIPV4 *mUniqueIPForConnection;
	static int unsigned VC_INC; //increment for all virtual connection
	int unsigned id; //the id of this virtual connection
	boost::signals2::mutex mMtx;
	string makeRandomMACAddress();
	string makeSequentialMACAddress();
	int getPacketIdentification(Packet* packet)
	{
		if (packet == NULL) {return -1;}
		IP* ip = packet->GetLayer<IP>();
		if (ip != NULL)
		{
			int temp = (uint32_t)ip->GetIdentification();
			return temp;
		}
		return -1;
	}
};

#endif /* CVIRTUALCONNECTION_H_ */
